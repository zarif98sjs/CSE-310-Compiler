Line 1: type_specifier : INT

int

Line 1: declaration_list : ID LTHIRD CONST_INT RTHIRD

save[7]

Line 1: var_declaration : type_specifier declaration_list SEMICOLON

int save[7];

Line 1: unit : var_declaration

int save[7];

Line 1: program : unit

int save[7];

Line 2: type_specifier : INT

int

Line 2: type_specifier : INT

int

Line 2: parameter_list : type_specifier ID

int n

Line 4: variable : ID

n

Line 4: factor : variable

n

Line 4: unary_expression : factor

n

Line 4: term : unary_expression

n

Line 4: simple_expression : term

n

Line 4: rel_expression : simple_expression

n

Line 4: logic_expression : rel_expression

n

Line 4: expression : logic_expression

n

Line 4: variable : ID LTHIRD expression RTHIRD

save[n]

Line 4: factor : variable

save[n]

Line 4: unary_expression : factor

save[n]

Line 4: term : unary_expression

save[n]

Line 4: simple_expression : term

save[n]

Line 4: factor : CONST_INT

1

Line 4: unary_expression : factor

1

Line 4: unary_expression : ADDOP unary_expression

-1

Line 4: term : unary_expression

-1

Line 4: simple_expression : term

-1

Line 4: rel_expression : simple_expression RELOP simple_expression

save[n]!=-1

Line 4: logic_expression : rel_expression

save[n]!=-1

Line 4: expression : logic_expression

save[n]!=-1

Line 6: variable : ID

n

Line 6: factor : variable

n

Line 6: unary_expression : factor

n

Line 6: term : unary_expression

n

Line 6: simple_expression : term

n

Line 6: rel_expression : simple_expression

n

Line 6: logic_expression : rel_expression

n

Line 6: expression : logic_expression

n

Line 6: variable : ID LTHIRD expression RTHIRD

save[n]

Line 6: factor : variable

save[n]

Line 6: unary_expression : factor

save[n]

Line 6: term : unary_expression

save[n]

Line 6: simple_expression : term

save[n]

Line 6: rel_expression : simple_expression

save[n]

Line 6: logic_expression : rel_expression

save[n]

Line 6: expression : logic_expression

save[n]

Line 6: statement : RETURN expression SEMICOLON

return save[n];

Line 6: statements : statement

return save[n];

Line 7: compound_statement : LCURL statements RCURL

{
return save[n];
}

ScopeTable # 1.1.1
20 --> < n , ID > 

ScopeTable # 1.1
20 --> < n , ID > 

ScopeTable # 1
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 7: statement : compound_statement

{
return save[n];
}

Line 8: variable : ID

n

Line 8: factor : variable

n

Line 8: unary_expression : factor

n

Line 8: term : unary_expression

n

Line 8: simple_expression : term

n

Line 8: factor : CONST_INT

1

Line 8: unary_expression : factor

1

Line 8: term : unary_expression

1

Line 8: simple_expression : term

1

Line 8: rel_expression : simple_expression RELOP simple_expression

n<=1

Line 8: logic_expression : rel_expression

n<=1

Line 8: expression : logic_expression

n<=1

Line 10: variable : ID

n

Line 10: factor : variable

n

Line 10: unary_expression : factor

n

Line 10: term : unary_expression

n

Line 10: simple_expression : term

n

Line 10: rel_expression : simple_expression

n

Line 10: logic_expression : rel_expression

n

Line 10: expression : logic_expression

n

Line 10: variable : ID LTHIRD expression RTHIRD

save[n]

Line 10: variable : ID

n

Line 10: factor : variable

n

Line 10: unary_expression : factor

n

Line 10: term : unary_expression

n

Line 10: simple_expression : term

n

Line 10: rel_expression : simple_expression

n

Line 10: logic_expression : rel_expression

n

Line 10: expression : variable ASSIGNOP logic_expression

save[n]=n

Line 10: expression_statement : expression SEMICOLON

save[n]=n;

Line 10: statement : expression_statement

save[n]=n;

Line 10: statements : statement

save[n]=n;

Line 11: variable : ID

n

Line 11: factor : variable

n

Line 11: unary_expression : factor

n

Line 11: term : unary_expression

n

Line 11: simple_expression : term

n

Line 11: rel_expression : simple_expression

n

Line 11: logic_expression : rel_expression

n

Line 11: expression : logic_expression

n

Line 11: variable : ID LTHIRD expression RTHIRD

save[n]

Line 11: factor : variable

save[n]

Line 11: unary_expression : factor

save[n]

Line 11: term : unary_expression

save[n]

Line 11: simple_expression : term

save[n]

Line 11: rel_expression : simple_expression

save[n]

Line 11: logic_expression : rel_expression

save[n]

Line 11: expression : logic_expression

save[n]

Line 11: statement : RETURN expression SEMICOLON

return save[n];

Line 11: statements : statements statement

save[n]=n;
return save[n];

Line 12: compound_statement : LCURL statements RCURL

{
save[n]=n;
return save[n];
}

ScopeTable # 1.1.2
20 --> < n , ID > 

ScopeTable # 1.1
20 --> < n , ID > 

ScopeTable # 1
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 12: statement : compound_statement

{
save[n]=n;
return save[n];
}

Line 15: variable : ID

n

Line 15: factor : variable

n

Line 15: unary_expression : factor

n

Line 15: term : unary_expression

n

Line 15: simple_expression : term

n

Line 15: rel_expression : simple_expression

n

Line 15: logic_expression : rel_expression

n

Line 15: expression : logic_expression

n

Line 15: variable : ID LTHIRD expression RTHIRD

save[n]

Line 15: variable : ID

n

Line 15: factor : variable

n

Line 15: unary_expression : factor

n

Line 15: term : unary_expression

n

Line 15: simple_expression : term

n

Line 15: factor : CONST_INT

1

Line 15: unary_expression : factor

1

Line 15: term : unary_expression

1

Line 15: simple_expression : simple_expression ADDOP term

n-1

Line 15: rel_expression : simple_expression

n-1

Line 15: logic_expression : rel_expression

n-1

Line 15: arguments : logic_expression

n-1

Line 15: argument_list : arguments

n-1

Line 15: factor : ID LPAREN argument_list RPAREN

fibo(n-1)

Line 15: unary_expression : factor

fibo(n-1)

Line 15: term : unary_expression

fibo(n-1)

Line 15: simple_expression : term

fibo(n-1)

Line 15: variable : ID

n

Line 15: factor : variable

n

Line 15: unary_expression : factor

n

Line 15: term : unary_expression

n

Line 15: simple_expression : term

n

Line 15: factor : CONST_INT

2

Line 15: unary_expression : factor

2

Line 15: term : unary_expression

2

Line 15: simple_expression : simple_expression ADDOP term

n-2

Line 15: rel_expression : simple_expression

n-2

Line 15: logic_expression : rel_expression

n-2

Line 15: arguments : logic_expression

n-2

Line 15: argument_list : arguments

n-2

Line 15: factor : ID LPAREN argument_list RPAREN

fibo(n-2)

Line 15: unary_expression : factor

fibo(n-2)

Line 15: term : unary_expression

fibo(n-2)

Line 15: simple_expression : simple_expression ADDOP term

fibo(n-1)+fibo(n-2)

Line 15: rel_expression : simple_expression

fibo(n-1)+fibo(n-2)

Line 15: logic_expression : rel_expression

fibo(n-1)+fibo(n-2)

Line 15: expression : variable ASSIGNOP logic_expression

save[n]=fibo(n-1)+fibo(n-2)

Line 15: expression_statement : expression SEMICOLON

save[n]=fibo(n-1)+fibo(n-2);

Line 15: statement : expression_statement

save[n]=fibo(n-1)+fibo(n-2);

Line 15: statements : statement

save[n]=fibo(n-1)+fibo(n-2);

Line 16: variable : ID

n

Line 16: factor : variable

n

Line 16: unary_expression : factor

n

Line 16: term : unary_expression

n

Line 16: simple_expression : term

n

Line 16: rel_expression : simple_expression

n

Line 16: logic_expression : rel_expression

n

Line 16: expression : logic_expression

n

Line 16: variable : ID LTHIRD expression RTHIRD

save[n]

Line 16: factor : variable

save[n]

Line 16: unary_expression : factor

save[n]

Line 16: term : unary_expression

save[n]

Line 16: simple_expression : term

save[n]

Line 16: rel_expression : simple_expression

save[n]

Line 16: logic_expression : rel_expression

save[n]

Line 16: expression : logic_expression

save[n]

Line 16: statement : RETURN expression SEMICOLON

return save[n];

Line 16: statements : statements statement

save[n]=fibo(n-1)+fibo(n-2);
return save[n];

Line 17: compound_statement : LCURL statements RCURL

{
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}

ScopeTable # 1.1.3
20 --> < n , ID > 

ScopeTable # 1.1
20 --> < n , ID > 

ScopeTable # 1
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 17: statement : compound_statement

{
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}

Line 17: statement : IF LPAREN expression RPAREN statement ELSE statement

if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}

Line 17: statement : IF LPAREN expression RPAREN statement ELSE statement

if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}

Line 17: statements : statement

if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}

Line 18: compound_statement : LCURL statements RCURL

{
if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}
}

ScopeTable # 1.1
20 --> < n , ID > 

ScopeTable # 1
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 18: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

int fibo(int n){
if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}
}

Line 18: unit : func_definition

int fibo(int n){
if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}
}

Line 18: program : program unit

int save[7];
int fibo(int n){
if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}
}

Line 19: type_specifier : INT

int

Line 21: type_specifier : INT

int

Line 21: declaration_list : ID

i

Line 21: var_declaration : type_specifier declaration_list SEMICOLON

int i;

Line 21: statement : var_declaration

int i;

Line 21: statements : statement

int i;

Line 22: variable : ID

i

Line 22: factor : CONST_INT

0

Line 22: unary_expression : factor

0

Line 22: term : unary_expression

0

Line 22: simple_expression : term

0

Line 22: rel_expression : simple_expression

0

Line 22: logic_expression : rel_expression

0

Line 22: expression : variable ASSIGNOP logic_expression

i=0

Line 22: expression_statement : expression SEMICOLON

i=0;

Line 22: statement : expression_statement

i=0;

Line 22: statements : statements statement

int i;
i=0;

Line 23: variable : ID

i

Line 23: factor : CONST_INT

0

Line 23: unary_expression : factor

0

Line 23: term : unary_expression

0

Line 23: simple_expression : term

0

Line 23: rel_expression : simple_expression

0

Line 23: logic_expression : rel_expression

0

Line 23: expression : variable ASSIGNOP logic_expression

i=0

Line 23: expression_statement : expression SEMICOLON

i=0;

Line 23: variable : ID

i

Line 23: factor : variable

i

Line 23: unary_expression : factor

i

Line 23: term : unary_expression

i

Line 23: simple_expression : term

i

Line 23: factor : CONST_INT

6

Line 23: unary_expression : factor

6

Line 23: term : unary_expression

6

Line 23: simple_expression : term

6

Line 23: rel_expression : simple_expression RELOP simple_expression

i<=6

Line 23: logic_expression : rel_expression

i<=6

Line 23: expression : logic_expression

i<=6

Line 23: expression_statement : expression SEMICOLON

i<=6;

Line 23: variable : ID

i

Line 23: factor : variable INCOP

i++

Line 23: unary_expression : factor

i++

Line 23: term : unary_expression

i++

Line 23: simple_expression : term

i++

Line 23: rel_expression : simple_expression

i++

Line 23: logic_expression : rel_expression

i++

Line 23: expression : logic_expression

i++

Line 25: variable : ID

i

Line 25: factor : variable

i

Line 25: unary_expression : factor

i

Line 25: term : unary_expression

i

Line 25: simple_expression : term

i

Line 25: rel_expression : simple_expression

i

Line 25: logic_expression : rel_expression

i

Line 25: expression : logic_expression

i

Line 25: variable : ID LTHIRD expression RTHIRD

save[i]

Line 25: factor : CONST_INT

1

Line 25: unary_expression : factor

1

Line 25: unary_expression : ADDOP unary_expression

-1

Line 25: term : unary_expression

-1

Line 25: simple_expression : term

-1

Line 25: rel_expression : simple_expression

-1

Line 25: logic_expression : rel_expression

-1

Line 25: expression : variable ASSIGNOP logic_expression

save[i]=-1

Line 25: expression_statement : expression SEMICOLON

save[i]=-1;

Line 25: statement : expression_statement

save[i]=-1;

Line 25: statements : statement

save[i]=-1;

Line 26: compound_statement : LCURL statements RCURL

{
save[i]=-1;
}

ScopeTable # 1.2.1

ScopeTable # 1.2
15 --> < i , ID > 

ScopeTable # 1
1 --> < main , ID > 
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 26: statement : compound_statement

{
save[i]=-1;
}

Line 26: statement : FOR LPAREN expression_statement expression_statement expression RPAREN statement

for(i=0;i<=6;i++){
save[i]=-1;
}

Line 26: statements : statements statement

int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}

Line 27: type_specifier : INT

int

Line 27: declaration_list : ID

pr

Line 27: var_declaration : type_specifier declaration_list SEMICOLON

int pr;

Line 27: statement : var_declaration

int pr;

Line 27: statements : statements statement

int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;

Line 28: variable : ID

i

Line 28: factor : CONST_INT

6

Line 28: unary_expression : factor

6

Line 28: term : unary_expression

6

Line 28: simple_expression : term

6

Line 28: rel_expression : simple_expression

6

Line 28: logic_expression : rel_expression

6

Line 28: expression : variable ASSIGNOP logic_expression

i=6

Line 28: expression_statement : expression SEMICOLON

i=6;

Line 28: variable : ID

i

Line 28: factor : variable

i

Line 28: unary_expression : factor

i

Line 28: term : unary_expression

i

Line 28: simple_expression : term

i

Line 28: factor : CONST_INT

1

Line 28: unary_expression : factor

1

Line 28: unary_expression : ADDOP unary_expression

-1

Line 28: term : unary_expression

-1

Line 28: simple_expression : term

-1

Line 28: rel_expression : simple_expression RELOP simple_expression

i>-1

Line 28: logic_expression : rel_expression

i>-1

Line 28: expression : logic_expression

i>-1

Line 28: expression_statement : expression SEMICOLON

i>-1;

Line 28: variable : ID

i

Line 28: factor : variable DECOP

i--

Line 28: unary_expression : factor

i--

Line 28: term : unary_expression

i--

Line 28: simple_expression : term

i--

Line 28: rel_expression : simple_expression

i--

Line 28: logic_expression : rel_expression

i--

Line 28: expression : logic_expression

i--

Line 30: variable : ID

pr

Line 30: variable : ID

i

Line 30: factor : variable

i

Line 30: unary_expression : factor

i

Line 30: term : unary_expression

i

Line 30: simple_expression : term

i

Line 30: rel_expression : simple_expression

i

Line 30: logic_expression : rel_expression

i

Line 30: arguments : logic_expression

i

Line 30: argument_list : arguments

i

Line 30: factor : ID LPAREN argument_list RPAREN

fibo(i)

Line 30: unary_expression : factor

fibo(i)

Line 30: term : unary_expression

fibo(i)

Line 30: simple_expression : term

fibo(i)

Line 30: rel_expression : simple_expression

fibo(i)

Line 30: logic_expression : rel_expression

fibo(i)

Line 30: expression : variable ASSIGNOP logic_expression

pr=fibo(i)

Line 30: expression_statement : expression SEMICOLON

pr=fibo(i);

Line 30: statement : expression_statement

pr=fibo(i);

Line 30: statements : statement

pr=fibo(i);

Line 31: statement : PRINTLN LPAREN ID RPAREN SEMICOLON

printf(pr);

Line 31: statements : statements statement

pr=fibo(i);
printf(pr);

Line 32: compound_statement : LCURL statements RCURL

{
pr=fibo(i);
printf(pr);
}

ScopeTable # 1.2.2

ScopeTable # 1.2
15 --> < i , ID > 
16 --> < pr , ID > 

ScopeTable # 1
1 --> < main , ID > 
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 32: statement : compound_statement

{
pr=fibo(i);
printf(pr);
}

Line 32: statement : FOR LPAREN expression_statement expression_statement expression RPAREN statement

for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}

Line 32: statements : statements statement

int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;
for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}

Line 33: factor : CONST_INT

0

Line 33: unary_expression : factor

0

Line 33: term : unary_expression

0

Line 33: simple_expression : term

0

Line 33: rel_expression : simple_expression

0

Line 33: logic_expression : rel_expression

0

Line 33: expression : logic_expression

0

Line 33: statement : RETURN expression SEMICOLON

return 0;

Line 33: statements : statements statement

int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;
for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}
return 0;

Line 34: compound_statement : LCURL statements RCURL

{
int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;
for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}
return 0;
}

ScopeTable # 1.2
15 --> < i , ID > 
16 --> < pr , ID > 

ScopeTable # 1
1 --> < main , ID > 
11 --> < save , ID > 
26 --> < fibo , ID > 

Line 34: func_definition : type_specifier ID LPAREN RPAREN compound_statement

int main(){
int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;
for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}
return 0;
}

Line 34: unit : func_definition

int main(){
int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;
for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}
return 0;
}

Line 34: program : program unit

int save[7];
int fibo(int n){
if(save[n]!=-1){
return save[n];
}
else if(n<=1){
save[n]=n;
return save[n];
}
else {
save[n]=fibo(n-1)+fibo(n-2);
return save[n];
}
}
int main(){
int i;
i=0;
for(i=0;i<=6;i++){
save[i]=-1;
}
int pr;
for(i=6;i>-1;i--){
pr=fibo(i);
printf(pr);
}
return 0;
}

Line 34: start : program

ScopeTable # 1
1 --> < main , ID > 
11 --> < save , ID > 
26 --> < fibo , ID > 

Total lines: 34
Total errors: 0
