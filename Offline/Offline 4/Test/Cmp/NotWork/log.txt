Line 1: type_specifier : INT

int

Line 1: declaration_list : ID LTHIRD CONST_INT RTHIRD

arr[6]

Line 1: var_declaration : type_specifier declaration_list SEMICOLON

int arr[6];

Line 1: unit : var_declaration

int arr[6];

Line 1: program : unit

int arr[6];

Line 2: type_specifier : INT

int

Line 2: declaration_list : ID LTHIRD CONST_INT RTHIRD

leftArr[6]

Line 2: var_declaration : type_specifier declaration_list SEMICOLON

int leftArr[6];

Line 2: unit : var_declaration

int leftArr[6];

Line 2: program : program unit

int arr[6];
int leftArr[6];

Line 3: type_specifier : INT

int

Line 3: declaration_list : ID LTHIRD CONST_INT RTHIRD

rightArr[6]

Line 3: var_declaration : type_specifier declaration_list SEMICOLON

int rightArr[6];

Line 3: unit : var_declaration

int rightArr[6];

Line 3: program : program unit

int arr[6];
int leftArr[6];
int rightArr[6];

Line 5: type_specifier : VOID

void

Line 5: type_specifier : INT

int

Line 5: parameter_list : type_specifier ID

int start

Line 5: type_specifier : INT

int

Line 5: parameter_list : parameter_list COMMA type_specifier ID

int start,int mid

Line 5: type_specifier : INT

int

Line 5: parameter_list : parameter_list COMMA type_specifier ID

int start,int mid,int end

Line 8: type_specifier : INT

int

Line 8: declaration_list : ID

len1

Line 8: var_declaration : type_specifier declaration_list SEMICOLON

int len1;

Line 8: statement : var_declaration

int len1;

Line 8: statements : statement

int len1;

Line 9: variable : ID

len1

Line 9: variable : ID

mid

Line 9: factor : variable

mid

Line 9: unary_expression : factor

mid

Line 9: term : unary_expression

mid

Line 9: simple_expression : term

mid

Line 9: variable : ID

start

Line 9: factor : variable

start

Line 9: unary_expression : factor

start

Line 9: term : unary_expression

start

Line 9: simple_expression : simple_expression ADDOP term

mid-start

Line 9: factor : CONST_INT

1

Line 9: unary_expression : factor

1

Line 9: term : unary_expression

1

Line 9: simple_expression : simple_expression ADDOP term

mid-start+1

Line 9: rel_expression : simple_expression

mid-start+1

Line 9: logic_expression : rel_expression

mid-start+1

Line 9: expression : variable ASSIGNOP logic_expression

len1=mid-start+1

Line 9: expression_statement : expression SEMICOLON

len1=mid-start+1;

Line 9: statement : expression_statement

len1=mid-start+1;

Line 9: statements : statements statement

int len1;
len1=mid-start+1;

Line 10: type_specifier : INT

int

Line 10: declaration_list : ID

len2

Line 10: var_declaration : type_specifier declaration_list SEMICOLON

int len2;

Line 10: statement : var_declaration

int len2;

Line 10: statements : statements statement

int len1;
len1=mid-start+1;
int len2;

Line 11: variable : ID

len2

Line 11: variable : ID

end

Line 11: factor : variable

end

Line 11: unary_expression : factor

end

Line 11: term : unary_expression

end

Line 11: simple_expression : term

end

Line 11: variable : ID

mid

Line 11: factor : variable

mid

Line 11: unary_expression : factor

mid

Line 11: term : unary_expression

mid

Line 11: simple_expression : simple_expression ADDOP term

end-mid

Line 11: rel_expression : simple_expression

end-mid

Line 11: logic_expression : rel_expression

end-mid

Line 11: expression : variable ASSIGNOP logic_expression

len2=end-mid

Line 11: expression_statement : expression SEMICOLON

len2=end-mid;

Line 11: statement : expression_statement

len2=end-mid;

Line 11: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;

Line 13: type_specifier : INT

int

Line 13: declaration_list : ID

i

Line 13: var_declaration : type_specifier declaration_list SEMICOLON

int i;

Line 13: statement : var_declaration

int i;

Line 13: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;

Line 14: variable : ID

i

Line 14: factor : CONST_INT

0

Line 14: unary_expression : factor

0

Line 14: term : unary_expression

0

Line 14: simple_expression : term

0

Line 14: rel_expression : simple_expression

0

Line 14: logic_expression : rel_expression

0

Line 14: expression : variable ASSIGNOP logic_expression

i=0

Line 14: expression_statement : expression SEMICOLON

i=0;

Line 14: variable : ID

i

Line 14: factor : variable

i

Line 14: unary_expression : factor

i

Line 14: term : unary_expression

i

Line 14: simple_expression : term

i

Line 14: variable : ID

len1

Line 14: factor : variable

len1

Line 14: unary_expression : factor

len1

Line 14: term : unary_expression

len1

Line 14: simple_expression : term

len1

Line 14: rel_expression : simple_expression RELOP simple_expression

i<len1

Line 14: logic_expression : rel_expression

i<len1

Line 14: expression : logic_expression

i<len1

Line 14: expression_statement : expression SEMICOLON

i<len1;

Line 14: variable : ID

i

Line 14: factor : variable INCOP

i++

Line 14: unary_expression : factor

i++

Line 14: term : unary_expression

i++

Line 14: simple_expression : term

i++

Line 14: rel_expression : simple_expression

i++

Line 14: logic_expression : rel_expression

i++

Line 14: expression : logic_expression

i++

Line 15: variable : ID

i

Line 15: factor : variable

i

Line 15: unary_expression : factor

i

Line 15: term : unary_expression

i

Line 15: simple_expression : term

i

Line 15: rel_expression : simple_expression

i

Line 15: logic_expression : rel_expression

i

Line 15: expression : logic_expression

i

Line 15: variable : ID LTHIRD expression RTHIRD

leftArr[i]

Line 15: variable : ID

start

Line 15: factor : variable

start

Line 15: unary_expression : factor

start

Line 15: term : unary_expression

start

Line 15: simple_expression : term

start

Line 15: variable : ID

i

Line 15: factor : variable

i

Line 15: unary_expression : factor

i

Line 15: term : unary_expression

i

Line 15: simple_expression : simple_expression ADDOP term

start+i

Line 15: rel_expression : simple_expression

start+i

Line 15: logic_expression : rel_expression

start+i

Line 15: expression : logic_expression

start+i

Line 15: variable : ID LTHIRD expression RTHIRD

arr[start+i]

Line 15: factor : variable

arr[start+i]

Line 15: unary_expression : factor

arr[start+i]

Line 15: term : unary_expression

arr[start+i]

Line 15: simple_expression : term

arr[start+i]

Line 15: rel_expression : simple_expression

arr[start+i]

Line 15: logic_expression : rel_expression

arr[start+i]

Line 15: expression : variable ASSIGNOP logic_expression

leftArr[i]=arr[start+i]

Line 15: expression_statement : expression SEMICOLON

leftArr[i]=arr[start+i];

Line 15: statement : expression_statement

leftArr[i]=arr[start+i];

Line 15: statement : FOR LPAREN expression_statement expression_statement expression RPAREN statement

for(i=0;i<len1;i++)leftArr[i]=arr[start+i];

Line 15: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];

Line 17: type_specifier : INT

int

Line 17: declaration_list : ID

j

Line 17: var_declaration : type_specifier declaration_list SEMICOLON

int j;

Line 17: statement : var_declaration

int j;

Line 17: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;

Line 18: variable : ID

j

Line 18: factor : CONST_INT

0

Line 18: unary_expression : factor

0

Line 18: term : unary_expression

0

Line 18: simple_expression : term

0

Line 18: rel_expression : simple_expression

0

Line 18: logic_expression : rel_expression

0

Line 18: expression : variable ASSIGNOP logic_expression

j=0

Line 18: expression_statement : expression SEMICOLON

j=0;

Line 18: variable : ID

j

Line 18: factor : variable

j

Line 18: unary_expression : factor

j

Line 18: term : unary_expression

j

Line 18: simple_expression : term

j

Line 18: variable : ID

len2

Line 18: factor : variable

len2

Line 18: unary_expression : factor

len2

Line 18: term : unary_expression

len2

Line 18: simple_expression : term

len2

Line 18: rel_expression : simple_expression RELOP simple_expression

j<len2

Line 18: logic_expression : rel_expression

j<len2

Line 18: expression : logic_expression

j<len2

Line 18: expression_statement : expression SEMICOLON

j<len2;

Line 18: variable : ID

j

Line 18: factor : variable INCOP

j++

Line 18: unary_expression : factor

j++

Line 18: term : unary_expression

j++

Line 18: simple_expression : term

j++

Line 18: rel_expression : simple_expression

j++

Line 18: logic_expression : rel_expression

j++

Line 18: expression : logic_expression

j++

Line 19: variable : ID

j

Line 19: factor : variable

j

Line 19: unary_expression : factor

j

Line 19: term : unary_expression

j

Line 19: simple_expression : term

j

Line 19: rel_expression : simple_expression

j

Line 19: logic_expression : rel_expression

j

Line 19: expression : logic_expression

j

Line 19: variable : ID LTHIRD expression RTHIRD

rightArr[j]

Line 19: variable : ID

mid

Line 19: factor : variable

mid

Line 19: unary_expression : factor

mid

Line 19: term : unary_expression

mid

Line 19: simple_expression : term

mid

Line 19: factor : CONST_INT

1

Line 19: unary_expression : factor

1

Line 19: term : unary_expression

1

Line 19: simple_expression : simple_expression ADDOP term

mid+1

Line 19: variable : ID

j

Line 19: factor : variable

j

Line 19: unary_expression : factor

j

Line 19: term : unary_expression

j

Line 19: simple_expression : simple_expression ADDOP term

mid+1+j

Line 19: rel_expression : simple_expression

mid+1+j

Line 19: logic_expression : rel_expression

mid+1+j

Line 19: expression : logic_expression

mid+1+j

Line 19: variable : ID LTHIRD expression RTHIRD

arr[mid+1+j]

Line 19: factor : variable

arr[mid+1+j]

Line 19: unary_expression : factor

arr[mid+1+j]

Line 19: term : unary_expression

arr[mid+1+j]

Line 19: simple_expression : term

arr[mid+1+j]

Line 19: rel_expression : simple_expression

arr[mid+1+j]

Line 19: logic_expression : rel_expression

arr[mid+1+j]

Line 19: expression : variable ASSIGNOP logic_expression

rightArr[j]=arr[mid+1+j]

Line 19: expression_statement : expression SEMICOLON

rightArr[j]=arr[mid+1+j];

Line 19: statement : expression_statement

rightArr[j]=arr[mid+1+j];

Line 19: statement : FOR LPAREN expression_statement expression_statement expression RPAREN statement

for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];

Line 19: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];

Line 21: type_specifier : INT

int

Line 21: declaration_list : ID

k

Line 21: var_declaration : type_specifier declaration_list SEMICOLON

int k;

Line 21: statement : var_declaration

int k;

Line 21: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;

Line 22: variable : ID

i

Line 22: factor : CONST_INT

0

Line 22: unary_expression : factor

0

Line 22: term : unary_expression

0

Line 22: simple_expression : term

0

Line 22: rel_expression : simple_expression

0

Line 22: logic_expression : rel_expression

0

Line 22: expression : variable ASSIGNOP logic_expression

i=0

Line 22: expression_statement : expression SEMICOLON

i=0;

Line 22: statement : expression_statement

i=0;

Line 22: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;

Line 23: variable : ID

j

Line 23: factor : CONST_INT

0

Line 23: unary_expression : factor

0

Line 23: term : unary_expression

0

Line 23: simple_expression : term

0

Line 23: rel_expression : simple_expression

0

Line 23: logic_expression : rel_expression

0

Line 23: expression : variable ASSIGNOP logic_expression

j=0

Line 23: expression_statement : expression SEMICOLON

j=0;

Line 23: statement : expression_statement

j=0;

Line 23: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;

Line 24: variable : ID

k

Line 24: variable : ID

start

Line 24: factor : variable

start

Line 24: unary_expression : factor

start

Line 24: term : unary_expression

start

Line 24: simple_expression : term

start

Line 24: rel_expression : simple_expression

start

Line 24: logic_expression : rel_expression

start

Line 24: expression : variable ASSIGNOP logic_expression

k=start

Line 24: expression_statement : expression SEMICOLON

k=start;

Line 24: statement : expression_statement

k=start;

Line 24: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;

Line 26: variable : ID

i

Line 26: factor : variable

i

Line 26: unary_expression : factor

i

Line 26: term : unary_expression

i

Line 26: simple_expression : term

i

Line 26: variable : ID

len1

Line 26: factor : variable

len1

Line 26: unary_expression : factor

len1

Line 26: term : unary_expression

len1

Line 26: simple_expression : term

len1

Line 26: rel_expression : simple_expression RELOP simple_expression

i<len1

Line 26: variable : ID

j

Line 26: factor : variable

j

Line 26: unary_expression : factor

j

Line 26: term : unary_expression

j

Line 26: simple_expression : term

j

Line 26: variable : ID

len2

Line 26: factor : variable

len2

Line 26: unary_expression : factor

len2

Line 26: term : unary_expression

len2

Line 26: simple_expression : term

len2

Line 26: rel_expression : simple_expression RELOP simple_expression

j<len2

Line 26: logic_expression : rel_expression LOGICOP rel_expression

i<len1&&j<len2

Line 26: expression : logic_expression

i<len1&&j<len2

Line 28: variable : ID

i

Line 28: factor : variable

i

Line 28: unary_expression : factor

i

Line 28: term : unary_expression

i

Line 28: simple_expression : term

i

Line 28: rel_expression : simple_expression

i

Line 28: logic_expression : rel_expression

i

Line 28: expression : logic_expression

i

Line 28: variable : ID LTHIRD expression RTHIRD

leftArr[i]

Line 28: factor : variable

leftArr[i]

Line 28: unary_expression : factor

leftArr[i]

Line 28: term : unary_expression

leftArr[i]

Line 28: simple_expression : term

leftArr[i]

Line 28: variable : ID

j

Line 28: factor : variable

j

Line 28: unary_expression : factor

j

Line 28: term : unary_expression

j

Line 28: simple_expression : term

j

Line 28: rel_expression : simple_expression

j

Line 28: logic_expression : rel_expression

j

Line 28: expression : logic_expression

j

Line 28: variable : ID LTHIRD expression RTHIRD

rightArr[j]

Line 28: factor : variable

rightArr[j]

Line 28: unary_expression : factor

rightArr[j]

Line 28: term : unary_expression

rightArr[j]

Line 28: simple_expression : term

rightArr[j]

Line 28: rel_expression : simple_expression RELOP simple_expression

leftArr[i]<=rightArr[j]

Line 28: logic_expression : rel_expression

leftArr[i]<=rightArr[j]

Line 28: expression : logic_expression

leftArr[i]<=rightArr[j]

Line 30: variable : ID

k

Line 30: factor : variable

k

Line 30: unary_expression : factor

k

Line 30: term : unary_expression

k

Line 30: simple_expression : term

k

Line 30: rel_expression : simple_expression

k

Line 30: logic_expression : rel_expression

k

Line 30: expression : logic_expression

k

Line 30: variable : ID LTHIRD expression RTHIRD

arr[k]

Line 30: variable : ID

i

Line 30: factor : variable

i

Line 30: unary_expression : factor

i

Line 30: term : unary_expression

i

Line 30: simple_expression : term

i

Line 30: rel_expression : simple_expression

i

Line 30: logic_expression : rel_expression

i

Line 30: expression : logic_expression

i

Line 30: variable : ID LTHIRD expression RTHIRD

leftArr[i]

Line 30: factor : variable

leftArr[i]

Line 30: unary_expression : factor

leftArr[i]

Line 30: term : unary_expression

leftArr[i]

Line 30: simple_expression : term

leftArr[i]

Line 30: rel_expression : simple_expression

leftArr[i]

Line 30: logic_expression : rel_expression

leftArr[i]

Line 30: expression : variable ASSIGNOP logic_expression

arr[k]=leftArr[i]

Line 30: expression_statement : expression SEMICOLON

arr[k]=leftArr[i];

Line 30: statement : expression_statement

arr[k]=leftArr[i];

Line 30: statements : statement

arr[k]=leftArr[i];

Line 31: variable : ID

i

Line 31: factor : variable INCOP

i++

Line 31: unary_expression : factor

i++

Line 31: term : unary_expression

i++

Line 31: simple_expression : term

i++

Line 31: rel_expression : simple_expression

i++

Line 31: logic_expression : rel_expression

i++

Line 31: expression : logic_expression

i++

Line 31: expression_statement : expression SEMICOLON

i++;

Line 31: statement : expression_statement

i++;

Line 31: statements : statements statement

arr[k]=leftArr[i];
i++;

Line 32: compound_statement : LCURL statements RCURL

{
arr[k]=leftArr[i];
i++;
}

ScopeTable # 1.1.1.1
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1.1
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1
8 --> < len1 , ID > 
9 --> < len2 , ID > 
11 --> < end , ID > 
14 --> < mid , ID > 
15 --> < i , ID > 
16 --> < j , ID > 
17 --> < k , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 32: statement : compound_statement

{
arr[k]=leftArr[i];
i++;
}

Line 35: variable : ID

k

Line 35: factor : variable

k

Line 35: unary_expression : factor

k

Line 35: term : unary_expression

k

Line 35: simple_expression : term

k

Line 35: rel_expression : simple_expression

k

Line 35: logic_expression : rel_expression

k

Line 35: expression : logic_expression

k

Line 35: variable : ID LTHIRD expression RTHIRD

arr[k]

Line 35: variable : ID

j

Line 35: factor : variable

j

Line 35: unary_expression : factor

j

Line 35: term : unary_expression

j

Line 35: simple_expression : term

j

Line 35: rel_expression : simple_expression

j

Line 35: logic_expression : rel_expression

j

Line 35: expression : logic_expression

j

Line 35: variable : ID LTHIRD expression RTHIRD

rightArr[j]

Line 35: factor : variable

rightArr[j]

Line 35: unary_expression : factor

rightArr[j]

Line 35: term : unary_expression

rightArr[j]

Line 35: simple_expression : term

rightArr[j]

Line 35: rel_expression : simple_expression

rightArr[j]

Line 35: logic_expression : rel_expression

rightArr[j]

Line 35: expression : variable ASSIGNOP logic_expression

arr[k]=rightArr[j]

Line 35: expression_statement : expression SEMICOLON

arr[k]=rightArr[j];

Line 35: statement : expression_statement

arr[k]=rightArr[j];

Line 35: statements : statement

arr[k]=rightArr[j];

Line 36: variable : ID

j

Line 36: factor : variable INCOP

j++

Line 36: unary_expression : factor

j++

Line 36: term : unary_expression

j++

Line 36: simple_expression : term

j++

Line 36: rel_expression : simple_expression

j++

Line 36: logic_expression : rel_expression

j++

Line 36: expression : logic_expression

j++

Line 36: expression_statement : expression SEMICOLON

j++;

Line 36: statement : expression_statement

j++;

Line 36: statements : statements statement

arr[k]=rightArr[j];
j++;

Line 37: compound_statement : LCURL statements RCURL

{
arr[k]=rightArr[j];
j++;
}

ScopeTable # 1.1.1.2
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1.1
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1
8 --> < len1 , ID > 
9 --> < len2 , ID > 
11 --> < end , ID > 
14 --> < mid , ID > 
15 --> < i , ID > 
16 --> < j , ID > 
17 --> < k , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 37: statement : compound_statement

{
arr[k]=rightArr[j];
j++;
}

Line 37: statement : IF LPAREN expression RPAREN statement ELSE statement

if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}

Line 37: statements : statement

if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}

Line 38: variable : ID

k

Line 38: factor : variable INCOP

k++

Line 38: unary_expression : factor

k++

Line 38: term : unary_expression

k++

Line 38: simple_expression : term

k++

Line 38: rel_expression : simple_expression

k++

Line 38: logic_expression : rel_expression

k++

Line 38: expression : logic_expression

k++

Line 38: expression_statement : expression SEMICOLON

k++;

Line 38: statement : expression_statement

k++;

Line 38: statements : statements statement

if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;

Line 39: compound_statement : LCURL statements RCURL

{
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}

ScopeTable # 1.1.1
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1
8 --> < len1 , ID > 
9 --> < len2 , ID > 
11 --> < end , ID > 
14 --> < mid , ID > 
15 --> < i , ID > 
16 --> < j , ID > 
17 --> < k , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 39: statement : compound_statement

{
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}

Line 39: statement : WHILE LPAREN expression RPAREN statement

while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}

Line 39: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}

Line 41: variable : ID

i

Line 41: factor : variable

i

Line 41: unary_expression : factor

i

Line 41: term : unary_expression

i

Line 41: simple_expression : term

i

Line 41: variable : ID

len1

Line 41: factor : variable

len1

Line 41: unary_expression : factor

len1

Line 41: term : unary_expression

len1

Line 41: simple_expression : term

len1

Line 41: rel_expression : simple_expression RELOP simple_expression

i<len1

Line 41: logic_expression : rel_expression

i<len1

Line 41: expression : logic_expression

i<len1

Line 43: variable : ID

k

Line 43: factor : variable

k

Line 43: unary_expression : factor

k

Line 43: term : unary_expression

k

Line 43: simple_expression : term

k

Line 43: rel_expression : simple_expression

k

Line 43: logic_expression : rel_expression

k

Line 43: expression : logic_expression

k

Line 43: variable : ID LTHIRD expression RTHIRD

arr[k]

Line 43: variable : ID

i

Line 43: factor : variable

i

Line 43: unary_expression : factor

i

Line 43: term : unary_expression

i

Line 43: simple_expression : term

i

Line 43: rel_expression : simple_expression

i

Line 43: logic_expression : rel_expression

i

Line 43: expression : logic_expression

i

Line 43: variable : ID LTHIRD expression RTHIRD

leftArr[i]

Line 43: factor : variable

leftArr[i]

Line 43: unary_expression : factor

leftArr[i]

Line 43: term : unary_expression

leftArr[i]

Line 43: simple_expression : term

leftArr[i]

Line 43: rel_expression : simple_expression

leftArr[i]

Line 43: logic_expression : rel_expression

leftArr[i]

Line 43: expression : variable ASSIGNOP logic_expression

arr[k]=leftArr[i]

Line 43: expression_statement : expression SEMICOLON

arr[k]=leftArr[i];

Line 43: statement : expression_statement

arr[k]=leftArr[i];

Line 43: statements : statement

arr[k]=leftArr[i];

Line 44: variable : ID

i

Line 44: factor : variable INCOP

i++

Line 44: unary_expression : factor

i++

Line 44: term : unary_expression

i++

Line 44: simple_expression : term

i++

Line 44: rel_expression : simple_expression

i++

Line 44: logic_expression : rel_expression

i++

Line 44: expression : logic_expression

i++

Line 44: expression_statement : expression SEMICOLON

i++;

Line 44: statement : expression_statement

i++;

Line 44: statements : statements statement

arr[k]=leftArr[i];
i++;

Line 45: variable : ID

k

Line 45: factor : variable INCOP

k++

Line 45: unary_expression : factor

k++

Line 45: term : unary_expression

k++

Line 45: simple_expression : term

k++

Line 45: rel_expression : simple_expression

k++

Line 45: logic_expression : rel_expression

k++

Line 45: expression : logic_expression

k++

Line 45: expression_statement : expression SEMICOLON

k++;

Line 45: statement : expression_statement

k++;

Line 45: statements : statements statement

arr[k]=leftArr[i];
i++;
k++;

Line 46: compound_statement : LCURL statements RCURL

{
arr[k]=leftArr[i];
i++;
k++;
}

ScopeTable # 1.1.2
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1
8 --> < len1 , ID > 
9 --> < len2 , ID > 
11 --> < end , ID > 
14 --> < mid , ID > 
15 --> < i , ID > 
16 --> < j , ID > 
17 --> < k , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 46: statement : compound_statement

{
arr[k]=leftArr[i];
i++;
k++;
}

Line 46: statement : WHILE LPAREN expression RPAREN statement

while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}

Line 46: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}

Line 48: variable : ID

j

Line 48: factor : variable

j

Line 48: unary_expression : factor

j

Line 48: term : unary_expression

j

Line 48: simple_expression : term

j

Line 48: variable : ID

len2

Line 48: factor : variable

len2

Line 48: unary_expression : factor

len2

Line 48: term : unary_expression

len2

Line 48: simple_expression : term

len2

Line 48: rel_expression : simple_expression RELOP simple_expression

j<len2

Line 48: logic_expression : rel_expression

j<len2

Line 48: expression : logic_expression

j<len2

Line 50: variable : ID

k

Line 50: factor : variable

k

Line 50: unary_expression : factor

k

Line 50: term : unary_expression

k

Line 50: simple_expression : term

k

Line 50: rel_expression : simple_expression

k

Line 50: logic_expression : rel_expression

k

Line 50: expression : logic_expression

k

Line 50: variable : ID LTHIRD expression RTHIRD

arr[k]

Line 50: variable : ID

j

Line 50: factor : variable

j

Line 50: unary_expression : factor

j

Line 50: term : unary_expression

j

Line 50: simple_expression : term

j

Line 50: rel_expression : simple_expression

j

Line 50: logic_expression : rel_expression

j

Line 50: expression : logic_expression

j

Line 50: variable : ID LTHIRD expression RTHIRD

rightArr[j]

Line 50: factor : variable

rightArr[j]

Line 50: unary_expression : factor

rightArr[j]

Line 50: term : unary_expression

rightArr[j]

Line 50: simple_expression : term

rightArr[j]

Line 50: rel_expression : simple_expression

rightArr[j]

Line 50: logic_expression : rel_expression

rightArr[j]

Line 50: expression : variable ASSIGNOP logic_expression

arr[k]=rightArr[j]

Line 50: expression_statement : expression SEMICOLON

arr[k]=rightArr[j];

Line 50: statement : expression_statement

arr[k]=rightArr[j];

Line 50: statements : statement

arr[k]=rightArr[j];

Line 51: variable : ID

j

Line 51: factor : variable INCOP

j++

Line 51: unary_expression : factor

j++

Line 51: term : unary_expression

j++

Line 51: simple_expression : term

j++

Line 51: rel_expression : simple_expression

j++

Line 51: logic_expression : rel_expression

j++

Line 51: expression : logic_expression

j++

Line 51: expression_statement : expression SEMICOLON

j++;

Line 51: statement : expression_statement

j++;

Line 51: statements : statements statement

arr[k]=rightArr[j];
j++;

Line 52: variable : ID

k

Line 52: factor : variable INCOP

k++

Line 52: unary_expression : factor

k++

Line 52: term : unary_expression

k++

Line 52: simple_expression : term

k++

Line 52: rel_expression : simple_expression

k++

Line 52: logic_expression : rel_expression

k++

Line 52: expression : logic_expression

k++

Line 52: expression_statement : expression SEMICOLON

k++;

Line 52: statement : expression_statement

k++;

Line 52: statements : statements statement

arr[k]=rightArr[j];
j++;
k++;

Line 53: compound_statement : LCURL statements RCURL

{
arr[k]=rightArr[j];
j++;
k++;
}

ScopeTable # 1.1.3
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.1
8 --> < len1 , ID > 
9 --> < len2 , ID > 
11 --> < end , ID > 
14 --> < mid , ID > 
15 --> < i , ID > 
16 --> < j , ID > 
17 --> < k , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 53: statement : compound_statement

{
arr[k]=rightArr[j];
j++;
k++;
}

Line 53: statement : WHILE LPAREN expression RPAREN statement

while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}

Line 53: statements : statements statement

int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}

Line 54: compound_statement : LCURL statements RCURL

{
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}

ScopeTable # 1.1
8 --> < len1 , ID > 
9 --> < len2 , ID > 
11 --> < end , ID > 
14 --> < mid , ID > 
15 --> < i , ID > 
16 --> < j , ID > 
17 --> < k , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 54: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

void merge(int start,int mid,int end){
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}

Line 54: unit : func_definition

void merge(int start,int mid,int end){
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}

Line 54: program : program unit

int arr[6];
int leftArr[6];
int rightArr[6];
void merge(int start,int mid,int end){
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}

Line 56: type_specifier : VOID

void

Line 56: type_specifier : INT

int

Line 56: parameter_list : type_specifier ID

int start

Line 56: type_specifier : INT

int

Line 56: parameter_list : parameter_list COMMA type_specifier ID

int start,int end

Line 58: variable : ID

start

Line 58: factor : variable

start

Line 58: unary_expression : factor

start

Line 58: term : unary_expression

start

Line 58: simple_expression : term

start

Line 58: variable : ID

end

Line 58: factor : variable

end

Line 58: unary_expression : factor

end

Line 58: term : unary_expression

end

Line 58: simple_expression : term

end

Line 58: rel_expression : simple_expression RELOP simple_expression

start<end

Line 58: logic_expression : rel_expression

start<end

Line 58: expression : logic_expression

start<end

Line 60: type_specifier : INT

int

Line 60: declaration_list : ID

mid

Line 60: var_declaration : type_specifier declaration_list SEMICOLON

int mid;

Line 60: statement : var_declaration

int mid;

Line 60: statements : statement

int mid;

Line 61: variable : ID

mid

Line 61: variable : ID

start

Line 61: factor : variable

start

Line 61: unary_expression : factor

start

Line 61: term : unary_expression

start

Line 61: simple_expression : term

start

Line 61: variable : ID

end

Line 61: factor : variable

end

Line 61: unary_expression : factor

end

Line 61: term : unary_expression

end

Line 61: simple_expression : term

end

Line 61: variable : ID

start

Line 61: factor : variable

start

Line 61: unary_expression : factor

start

Line 61: term : unary_expression

start

Line 61: simple_expression : simple_expression ADDOP term

end-start

Line 61: rel_expression : simple_expression

end-start

Line 61: logic_expression : rel_expression

end-start

Line 61: expression : logic_expression

end-start

Line 61: factor : LPAREN expression RPAREN

(end-start)

Line 61: unary_expression : factor

(end-start)

Line 61: term : unary_expression

(end-start)

Line 61: factor : CONST_INT

2

Line 61: unary_expression : factor

2

Line 61: term : term MULOP unary_expression

(end-start)/2

Line 61: simple_expression : simple_expression ADDOP term

start+(end-start)/2

Line 61: rel_expression : simple_expression

start+(end-start)/2

Line 61: logic_expression : rel_expression

start+(end-start)/2

Line 61: expression : variable ASSIGNOP logic_expression

mid=start+(end-start)/2

Line 61: expression_statement : expression SEMICOLON

mid=start+(end-start)/2;

Line 61: statement : expression_statement

mid=start+(end-start)/2;

Line 61: statements : statements statement

int mid;
mid=start+(end-start)/2;

Line 62: variable : ID

start

Line 62: factor : variable

start

Line 62: unary_expression : factor

start

Line 62: term : unary_expression

start

Line 62: simple_expression : term

start

Line 62: rel_expression : simple_expression

start

Line 62: logic_expression : rel_expression

start

Line 62: arguments : logic_expression

start

Line 62: variable : ID

mid

Line 62: factor : variable

mid

Line 62: unary_expression : factor

mid

Line 62: term : unary_expression

mid

Line 62: simple_expression : term

mid

Line 62: rel_expression : simple_expression

mid

Line 62: logic_expression : rel_expression

mid

Line 62: arguments : arguments COMMA logic_expression

start,mid

Line 62: argument_list : arguments

start,mid

Line 62: factor : ID LPAREN argument_list RPAREN

mergeSort(start,mid)

Line 62: unary_expression : factor

mergeSort(start,mid)

Line 62: term : unary_expression

mergeSort(start,mid)

Line 62: simple_expression : term

mergeSort(start,mid)

Line 62: rel_expression : simple_expression

mergeSort(start,mid)

Line 62: logic_expression : rel_expression

mergeSort(start,mid)

Line 62: expression : logic_expression

mergeSort(start,mid)

Line 62: expression_statement : expression SEMICOLON

mergeSort(start,mid);

Line 62: statement : expression_statement

mergeSort(start,mid);

Line 62: statements : statements statement

int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);

Line 63: variable : ID

mid

Line 63: factor : variable

mid

Line 63: unary_expression : factor

mid

Line 63: term : unary_expression

mid

Line 63: simple_expression : term

mid

Line 63: factor : CONST_INT

1

Line 63: unary_expression : factor

1

Line 63: term : unary_expression

1

Line 63: simple_expression : simple_expression ADDOP term

mid+1

Line 63: rel_expression : simple_expression

mid+1

Line 63: logic_expression : rel_expression

mid+1

Line 63: arguments : logic_expression

mid+1

Line 63: variable : ID

end

Line 63: factor : variable

end

Line 63: unary_expression : factor

end

Line 63: term : unary_expression

end

Line 63: simple_expression : term

end

Line 63: rel_expression : simple_expression

end

Line 63: logic_expression : rel_expression

end

Line 63: arguments : arguments COMMA logic_expression

mid+1,end

Line 63: argument_list : arguments

mid+1,end

Line 63: factor : ID LPAREN argument_list RPAREN

mergeSort(mid+1,end)

Line 63: unary_expression : factor

mergeSort(mid+1,end)

Line 63: term : unary_expression

mergeSort(mid+1,end)

Line 63: simple_expression : term

mergeSort(mid+1,end)

Line 63: rel_expression : simple_expression

mergeSort(mid+1,end)

Line 63: logic_expression : rel_expression

mergeSort(mid+1,end)

Line 63: expression : logic_expression

mergeSort(mid+1,end)

Line 63: expression_statement : expression SEMICOLON

mergeSort(mid+1,end);

Line 63: statement : expression_statement

mergeSort(mid+1,end);

Line 63: statements : statements statement

int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);

Line 64: variable : ID

start

Line 64: factor : variable

start

Line 64: unary_expression : factor

start

Line 64: term : unary_expression

start

Line 64: simple_expression : term

start

Line 64: rel_expression : simple_expression

start

Line 64: logic_expression : rel_expression

start

Line 64: arguments : logic_expression

start

Line 64: variable : ID

mid

Line 64: factor : variable

mid

Line 64: unary_expression : factor

mid

Line 64: term : unary_expression

mid

Line 64: simple_expression : term

mid

Line 64: rel_expression : simple_expression

mid

Line 64: logic_expression : rel_expression

mid

Line 64: arguments : arguments COMMA logic_expression

start,mid

Line 64: variable : ID

end

Line 64: factor : variable

end

Line 64: unary_expression : factor

end

Line 64: term : unary_expression

end

Line 64: simple_expression : term

end

Line 64: rel_expression : simple_expression

end

Line 64: logic_expression : rel_expression

end

Line 64: arguments : arguments COMMA logic_expression

start,mid,end

Line 64: argument_list : arguments

start,mid,end

Line 64: factor : ID LPAREN argument_list RPAREN

merge(start,mid,end)

Line 64: unary_expression : factor

merge(start,mid,end)

Line 64: term : unary_expression

merge(start,mid,end)

Line 64: simple_expression : term

merge(start,mid,end)

Line 64: rel_expression : simple_expression

merge(start,mid,end)

Line 64: logic_expression : rel_expression

merge(start,mid,end)

Line 64: expression : logic_expression

merge(start,mid,end)

Line 64: expression_statement : expression SEMICOLON

merge(start,mid,end);

Line 64: statement : expression_statement

merge(start,mid,end);

Line 64: statements : statements statement

int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);

Line 65: compound_statement : LCURL statements RCURL

{
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}

ScopeTable # 1.2.1
11 --> < end , ID > 
14 --> < mid , ID > 
18 --> < start , ID > 

ScopeTable # 1.2
11 --> < end , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
22 --> < mergeSort , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 65: statement : compound_statement

{
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}

Line 66: statement : IF LPAREN expression RPAREN statement

if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}

Line 66: statements : statement

if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}

Line 66: compound_statement : LCURL statements RCURL

{
if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}
}

ScopeTable # 1.2
11 --> < end , ID > 
18 --> < start , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
18 --> < merge , ID > 
22 --> < mergeSort , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 66: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

void mergeSort(int start,int end){
if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}
}

Line 66: unit : func_definition

void mergeSort(int start,int end){
if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}
}

Line 66: program : program unit

int arr[6];
int leftArr[6];
int rightArr[6];
void merge(int start,int mid,int end){
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}
void mergeSort(int start,int end){
if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}
}

Line 68: type_specifier : VOID

void

Line 68: type_specifier : INT

int

Line 68: parameter_list : type_specifier ID

int size

Line 70: type_specifier : INT

int

Line 70: declaration_list : ID

i

Line 70: var_declaration : type_specifier declaration_list SEMICOLON

int i;

Line 70: statement : var_declaration

int i;

Line 70: statements : statement

int i;

Line 71: variable : ID

i

Line 71: factor : CONST_INT

0

Line 71: unary_expression : factor

0

Line 71: term : unary_expression

0

Line 71: simple_expression : term

0

Line 71: rel_expression : simple_expression

0

Line 71: logic_expression : rel_expression

0

Line 71: expression : variable ASSIGNOP logic_expression

i=0

Line 71: expression_statement : expression SEMICOLON

i=0;

Line 71: variable : ID

i

Line 71: factor : variable

i

Line 71: unary_expression : factor

i

Line 71: term : unary_expression

i

Line 71: simple_expression : term

i

Line 71: variable : ID

size

Line 71: factor : variable

size

Line 71: unary_expression : factor

size

Line 71: term : unary_expression

size

Line 71: simple_expression : term

size

Line 71: rel_expression : simple_expression RELOP simple_expression

i<size

Line 71: logic_expression : rel_expression

i<size

Line 71: expression : logic_expression

i<size

Line 71: expression_statement : expression SEMICOLON

i<size;

Line 71: variable : ID

i

Line 71: factor : variable INCOP

i++

Line 71: unary_expression : factor

i++

Line 71: term : unary_expression

i++

Line 71: simple_expression : term

i++

Line 71: rel_expression : simple_expression

i++

Line 71: logic_expression : rel_expression

i++

Line 71: expression : logic_expression

i++

Line 72: variable : ID

i

Line 72: factor : variable

i

Line 72: unary_expression : factor

i

Line 72: term : unary_expression

i

Line 72: simple_expression : term

i

Line 72: rel_expression : simple_expression

i

Line 72: logic_expression : rel_expression

i

Line 72: expression : logic_expression

i

Line 72: statement : PRINTLN LPAREN ID RPAREN SEMICOLON

printf(arr[i]);

Line 72: statement : FOR LPAREN expression_statement expression_statement expression RPAREN statement

for(i=0;i<size;i++)printf(arr[i]);

Line 72: statements : statements statement

int i;
for(i=0;i<size;i++)printf(arr[i]);

Line 73: compound_statement : LCURL statements RCURL

{
int i;
for(i=0;i<size;i++)printf(arr[i]);
}

ScopeTable # 1.3
15 --> < i , ID > 
23 --> < size , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
8 --> < display , ID > 
18 --> < merge , ID > 
22 --> < mergeSort , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 73: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement

void display(int size){
int i;
for(i=0;i<size;i++)printf(arr[i]);
}

Line 73: unit : func_definition

void display(int size){
int i;
for(i=0;i<size;i++)printf(arr[i]);
}

Line 73: program : program unit

int arr[6];
int leftArr[6];
int rightArr[6];
void merge(int start,int mid,int end){
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}
void mergeSort(int start,int end){
if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}
}
void display(int size){
int i;
for(i=0;i<size;i++)printf(arr[i]);
}

Line 75: type_specifier : INT

int

Line 78: type_specifier : INT

int

Line 78: declaration_list : ID

size

Line 78: var_declaration : type_specifier declaration_list SEMICOLON

int size;

Line 78: statement : var_declaration

int size;

Line 78: statements : statement

int size;

Line 79: variable : ID

size

Line 79: factor : CONST_INT

4

Line 79: unary_expression : factor

4

Line 79: term : unary_expression

4

Line 79: simple_expression : term

4

Line 79: rel_expression : simple_expression

4

Line 79: logic_expression : rel_expression

4

Line 79: expression : variable ASSIGNOP logic_expression

size=4

Line 79: expression_statement : expression SEMICOLON

size=4;

Line 79: statement : expression_statement

size=4;

Line 79: statements : statements statement

int size;
size=4;

Line 81: factor : CONST_INT

0

Line 81: unary_expression : factor

0

Line 81: term : unary_expression

0

Line 81: simple_expression : term

0

Line 81: rel_expression : simple_expression

0

Line 81: logic_expression : rel_expression

0

Line 81: expression : logic_expression

0

Line 81: variable : ID LTHIRD expression RTHIRD

arr[0]

Line 81: factor : CONST_INT

5

Line 81: unary_expression : factor

5

Line 81: term : unary_expression

5

Line 81: simple_expression : term

5

Line 81: rel_expression : simple_expression

5

Line 81: logic_expression : rel_expression

5

Line 81: expression : variable ASSIGNOP logic_expression

arr[0]=5

Line 81: expression_statement : expression SEMICOLON

arr[0]=5;

Line 81: statement : expression_statement

arr[0]=5;

Line 81: statements : statements statement

int size;
size=4;
arr[0]=5;

Line 82: factor : CONST_INT

1

Line 82: unary_expression : factor

1

Line 82: term : unary_expression

1

Line 82: simple_expression : term

1

Line 82: rel_expression : simple_expression

1

Line 82: logic_expression : rel_expression

1

Line 82: expression : logic_expression

1

Line 82: variable : ID LTHIRD expression RTHIRD

arr[1]

Line 82: factor : CONST_INT

4

Line 82: unary_expression : factor

4

Line 82: term : unary_expression

4

Line 82: simple_expression : term

4

Line 82: rel_expression : simple_expression

4

Line 82: logic_expression : rel_expression

4

Line 82: expression : variable ASSIGNOP logic_expression

arr[1]=4

Line 82: expression_statement : expression SEMICOLON

arr[1]=4;

Line 82: statement : expression_statement

arr[1]=4;

Line 82: statements : statements statement

int size;
size=4;
arr[0]=5;
arr[1]=4;

Line 83: factor : CONST_INT

2

Line 83: unary_expression : factor

2

Line 83: term : unary_expression

2

Line 83: simple_expression : term

2

Line 83: rel_expression : simple_expression

2

Line 83: logic_expression : rel_expression

2

Line 83: expression : logic_expression

2

Line 83: variable : ID LTHIRD expression RTHIRD

arr[2]

Line 83: factor : CONST_INT

3

Line 83: unary_expression : factor

3

Line 83: term : unary_expression

3

Line 83: simple_expression : term

3

Line 83: rel_expression : simple_expression

3

Line 83: logic_expression : rel_expression

3

Line 83: expression : variable ASSIGNOP logic_expression

arr[2]=3

Line 83: expression_statement : expression SEMICOLON

arr[2]=3;

Line 83: statement : expression_statement

arr[2]=3;

Line 83: statements : statements statement

int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;

Line 84: factor : CONST_INT

3

Line 84: unary_expression : factor

3

Line 84: term : unary_expression

3

Line 84: simple_expression : term

3

Line 84: rel_expression : simple_expression

3

Line 84: logic_expression : rel_expression

3

Line 84: expression : logic_expression

3

Line 84: variable : ID LTHIRD expression RTHIRD

arr[3]

Line 84: factor : CONST_INT

12

Line 84: unary_expression : factor

12

Line 84: term : unary_expression

12

Line 84: simple_expression : term

12

Line 84: rel_expression : simple_expression

12

Line 84: logic_expression : rel_expression

12

Line 84: expression : variable ASSIGNOP logic_expression

arr[3]=12

Line 84: expression_statement : expression SEMICOLON

arr[3]=12;

Line 84: statement : expression_statement

arr[3]=12;

Line 84: statements : statements statement

int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;

Line 88: variable : ID

size

Line 88: factor : variable

size

Line 88: unary_expression : factor

size

Line 88: term : unary_expression

size

Line 88: simple_expression : term

size

Line 88: rel_expression : simple_expression

size

Line 88: logic_expression : rel_expression

size

Line 88: arguments : logic_expression

size

Line 88: argument_list : arguments

size

Line 88: factor : ID LPAREN argument_list RPAREN

display(size)

Line 88: unary_expression : factor

display(size)

Line 88: term : unary_expression

display(size)

Line 88: simple_expression : term

display(size)

Line 88: rel_expression : simple_expression

display(size)

Line 88: logic_expression : rel_expression

display(size)

Line 88: expression : logic_expression

display(size)

Line 88: expression_statement : expression SEMICOLON

display(size);

Line 88: statement : expression_statement

display(size);

Line 88: statements : statements statement

int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);

Line 90: factor : CONST_INT

0

Line 90: unary_expression : factor

0

Line 90: term : unary_expression

0

Line 90: simple_expression : term

0

Line 90: rel_expression : simple_expression

0

Line 90: logic_expression : rel_expression

0

Line 90: arguments : logic_expression

0

Line 90: variable : ID

size

Line 90: factor : variable

size

Line 90: unary_expression : factor

size

Line 90: term : unary_expression

size

Line 90: simple_expression : term

size

Line 90: factor : CONST_INT

1

Line 90: unary_expression : factor

1

Line 90: term : unary_expression

1

Line 90: simple_expression : simple_expression ADDOP term

size-1

Line 90: rel_expression : simple_expression

size-1

Line 90: logic_expression : rel_expression

size-1

Line 90: arguments : arguments COMMA logic_expression

0,size-1

Line 90: argument_list : arguments

0,size-1

Line 90: factor : ID LPAREN argument_list RPAREN

mergeSort(0,size-1)

Line 90: unary_expression : factor

mergeSort(0,size-1)

Line 90: term : unary_expression

mergeSort(0,size-1)

Line 90: simple_expression : term

mergeSort(0,size-1)

Line 90: rel_expression : simple_expression

mergeSort(0,size-1)

Line 90: logic_expression : rel_expression

mergeSort(0,size-1)

Line 90: expression : logic_expression

mergeSort(0,size-1)

Line 90: expression_statement : expression SEMICOLON

mergeSort(0,size-1);

Line 90: statement : expression_statement

mergeSort(0,size-1);

Line 90: statements : statements statement

int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);
mergeSort(0,size-1);

Line 92: variable : ID

size

Line 92: factor : variable

size

Line 92: unary_expression : factor

size

Line 92: term : unary_expression

size

Line 92: simple_expression : term

size

Line 92: rel_expression : simple_expression

size

Line 92: logic_expression : rel_expression

size

Line 92: arguments : logic_expression

size

Line 92: argument_list : arguments

size

Line 92: factor : ID LPAREN argument_list RPAREN

display(size)

Line 92: unary_expression : factor

display(size)

Line 92: term : unary_expression

display(size)

Line 92: simple_expression : term

display(size)

Line 92: rel_expression : simple_expression

display(size)

Line 92: logic_expression : rel_expression

display(size)

Line 92: expression : logic_expression

display(size)

Line 92: expression_statement : expression SEMICOLON

display(size);

Line 92: statement : expression_statement

display(size);

Line 92: statements : statements statement

int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);
mergeSort(0,size-1);
display(size);

Line 93: compound_statement : LCURL statements RCURL

{
int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);
mergeSort(0,size-1);
display(size);
}

ScopeTable # 1.4
23 --> < size , ID > 

ScopeTable # 1
0 --> < leftArr , ID > 
1 --> < main , ID > 
8 --> < display , ID > 
18 --> < merge , ID > 
22 --> < mergeSort , ID > 
25 --> < arr , ID > < rightArr , ID > 

Line 93: func_definition : type_specifier ID LPAREN RPAREN compound_statement

int main(){
int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);
mergeSort(0,size-1);
display(size);
}

Line 93: unit : func_definition

int main(){
int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);
mergeSort(0,size-1);
display(size);
}

Line 93: program : program unit

int arr[6];
int leftArr[6];
int rightArr[6];
void merge(int start,int mid,int end){
int len1;
len1=mid-start+1;
int len2;
len2=end-mid;
int i;
for(i=0;i<len1;i++)leftArr[i]=arr[start+i];
int j;
for(j=0;j<len2;j++)rightArr[j]=arr[mid+1+j];
int k;
i=0;
j=0;
k=start;
while(i<len1&&j<len2){
if(leftArr[i]<=rightArr[j]){
arr[k]=leftArr[i];
i++;
}
else {
arr[k]=rightArr[j];
j++;
}
k++;
}
while(i<len1){
arr[k]=leftArr[i];
i++;
k++;
}
while(j<len2){
arr[k]=rightArr[j];
j++;
k++;
}
}
void mergeSort(int start,int end){
if(start<end){
int mid;
mid=start+(end-start)/2;
mergeSort(start,mid);
mergeSort(mid+1,end);
merge(start,mid,end);
}
}
void display(int size){
int i;
for(i=0;i<size;i++)printf(arr[i]);
}
int main(){
int size;
size=4;
arr[0]=5;
arr[1]=4;
arr[2]=3;
arr[3]=12;
display(size);
mergeSort(0,size-1);
display(size);
}

Line 94: start : program

ScopeTable # 1
0 --> < leftArr , ID > 
1 --> < main , ID > 
8 --> < display , ID > 
18 --> < merge , ID > 
22 --> < mergeSort , ID > 
25 --> < arr , ID > < rightArr , ID > 

Total lines: 94
Total errors: 0
